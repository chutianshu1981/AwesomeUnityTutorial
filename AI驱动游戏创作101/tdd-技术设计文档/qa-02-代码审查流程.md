# ä»£ç å®¡æŸ¥æµç¨‹æ–‡æ¡£

## æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£ç¼–å·**: QA-02-CODEREVIEW
- **æ–‡æ¡£åç§°**: ä»£ç å®¡æŸ¥æµç¨‹æ–‡æ¡£
- **ç‰ˆæœ¬**: v1.0
- **åˆ›å»ºæ—¥æœŸ**: 2025-09-17
- **è´Ÿè´£äºº**: è´¨é‡ä¿è¯å›¢é˜Ÿ
- **å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸

---

## ä¸€ã€ä»£ç å®¡æŸ¥æ¦‚è¿°

### 1.1 å®¡æŸ¥ç›®æ ‡
- **ä»£ç è´¨é‡**: ç¡®ä¿ä»£ç ç¬¦åˆç¼–ç æ ‡å‡†å’Œæœ€ä½³å®è·µ
- **åŠŸèƒ½æ­£ç¡®æ€§**: éªŒè¯ä»£ç å®ç°ç¬¦åˆéœ€æ±‚å’Œè®¾è®¡è§„èŒƒ
- **æ€§èƒ½ä¼˜åŒ–**: è¯†åˆ«å’Œè§£å†³æ€§èƒ½é—®é¢˜
- **å®‰å…¨æ€§**: é˜²æ­¢å®‰å…¨æ¼æ´å’Œæ½œåœ¨é£é™©
- **å¯ç»´æŠ¤æ€§**: æé«˜ä»£ç çš„å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§

### 1.2 å®¡æŸ¥åŸåˆ™
- **å»ºè®¾æ€§**: æä¾›å»ºè®¾æ€§çš„åé¦ˆå’Œå»ºè®®
- **åŠæ—¶æ€§**: åŠæ—¶è¿›è¡Œå®¡æŸ¥ï¼Œä¸é˜»å¡å¼€å‘è¿›åº¦
- **å…¨é¢æ€§**: è¦†ç›–æ‰€æœ‰é‡è¦çš„ä»£ç å˜æ›´
- **ä¸€è‡´æ€§**: ç»Ÿä¸€çš„å®¡æŸ¥æ ‡å‡†å’Œæµç¨‹
- **åä½œæ€§**: ä¿ƒè¿›å›¢é˜Ÿæˆå‘˜é—´çš„çŸ¥è¯†å…±äº«

### 1.3 å®¡æŸ¥èŒƒå›´
- **æ–°åŠŸèƒ½ä»£ç **: æ‰€æœ‰æ–°å¢åŠŸèƒ½ä»£ç 
- **é‡æ„ä»£ç **: é‡è¦çš„é‡æ„å’Œä¼˜åŒ–
- **æ ¸å¿ƒç³»ç»Ÿ**: æ¸¸æˆç®¡ç†å™¨ã€æˆ˜æ–—ç³»ç»Ÿã€è§’è‰²ç³»ç»Ÿç­‰
- **æ€§èƒ½æ•æ„Ÿä»£ç **: æ¸²æŸ“ã€ç‰©ç†ã€AIç­‰
- **å®‰å…¨ç›¸å…³ä»£ç **: æ•°æ®å­˜å‚¨ã€ç½‘ç»œé€šä¿¡ç­‰

---

## äºŒã€ä»£ç å®¡æŸ¥æµç¨‹

### 2.1 å®¡æŸ¥æµç¨‹å›¾
```mermaid
graph TD
    A[å¼€å‘å®Œæˆä»£ç ] --> B[è‡ªæˆ‘æ£€æŸ¥]
    B --> C[æäº¤Pull Request]
    C --> D[åˆ†é…å®¡æŸ¥è€…]
    D --> E[è¿›è¡Œä»£ç å®¡æŸ¥]
    E --> F{å®¡æŸ¥é€šè¿‡?}
    F -->|æ˜¯| G[åˆå¹¶ä»£ç ]
    F -->|å¦| H[ä¿®æ”¹ä»£ç ]
    H --> B
    G --> I[éƒ¨ç½²æµ‹è¯•]
```

### 2.2 è¯¦ç»†æµç¨‹

#### 2.2.1 å¼€å‘é˜¶æ®µ
```csharp
// å¼€å‘äººå‘˜èŒè´£
1. éµå¾ªç¼–ç è§„èŒƒ
2. ç¼–å†™å•å…ƒæµ‹è¯•
3. è¿›è¡Œè‡ªæˆ‘æ£€æŸ¥
4. ç¼–å†™æ¸…æ™°çš„æäº¤ä¿¡æ¯
5. æä¾›å¿…è¦çš„æ–‡æ¡£å’Œæ³¨é‡Š

// è‡ªæˆ‘æ£€æŸ¥æ¸…å•
- [ ] ä»£ç ç¬¦åˆå‘½åè§„èŒƒ
- [ ] æ–¹æ³•é•¿åº¦åˆç†ï¼ˆä¸è¶…è¿‡50è¡Œï¼‰
- [ ] ç±»èŒè´£å•ä¸€
- [ ] å¼‚å¸¸å¤„ç†å®Œæ•´
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] ä»£ç æœ‰é€‚å½“çš„æ³¨é‡Š
- [ ] æäº¤ä¿¡æ¯æ¸…æ™°æ˜ç¡®
```

#### 2.2.2 æäº¤é˜¶æ®µ
```csharp
// Pull Requestæ¨¡æ¿
## å˜æ›´æè¿°
### å˜æ›´ç±»å‹
- [ ] æ–°åŠŸèƒ½
- [ ] Bugä¿®å¤
- [ ] é‡æ„
- [ ] æ–‡æ¡£æ›´æ–°
- [ ] æ€§èƒ½ä¼˜åŒ–

### å˜æ›´è¯¦æƒ…
ç®€è¦æè¿°è¿™ä¸ªPRçš„ç›®çš„å’Œä¸»è¦å˜æ›´å†…å®¹...

### æµ‹è¯•æƒ…å†µ
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] æ‰‹åŠ¨æµ‹è¯•å®Œæˆ
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡

### ç›¸å…³Issue
é“¾æ¥ç›¸å…³çš„Issueæˆ–ä»»åŠ¡...

### å®¡æŸ¥è€…æ³¨æ„äº‹é¡¹
è¯·é‡ç‚¹å…³æ³¨ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š
1. ä»£ç ç»“æ„å’Œè®¾è®¡æ¨¡å¼
2. æ€§èƒ½å½±å“
3. å®‰å…¨æ€§è€ƒè™‘
4. æµ‹è¯•è¦†ç›–ç‡
```

#### 2.2.3 å®¡æŸ¥é˜¶æ®µ
```csharp
// å®¡æŸ¥è€…èŒè´£
1. æ£€æŸ¥ä»£ç è´¨é‡å’Œè§„èŒƒæ€§
2. éªŒè¯åŠŸèƒ½å®ç°çš„æ­£ç¡®æ€§
3. è¯„ä¼°æ€§èƒ½å½±å“
4. æ£€æŸ¥å®‰å…¨æ€§é—®é¢˜
5. ç¡®ä¿æµ‹è¯•è¦†ç›–ç‡
6. æä¾›å»ºè®¾æ€§çš„åé¦ˆ

// å®¡æŸ¥æ¸…å•
- [ ] ä»£ç ç¬¦åˆé¡¹ç›®ç¼–ç è§„èŒƒ
- [ ] æ–¹æ³•èŒè´£å•ä¸€ä¸”æ¸…æ™°
- [ ] å¼‚å¸¸å¤„ç†å®Œæ•´
- [ ] æ€§èƒ½è€ƒè™‘å……åˆ†
- [ ] å®‰å…¨æ€§æ£€æŸ¥é€šè¿‡
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾æ ‡
- [ ] ä»£ç æ³¨é‡Šæ¸…æ™°å®Œæ•´
- [ ] å˜æ›´èŒƒå›´åˆç†
```

---

## ä¸‰ã€ä»£ç å®¡æŸ¥æ ‡å‡†

### 3.1 ç¼–ç è§„èŒƒæ£€æŸ¥

#### 3.1.1 å‘½åè§„èŒƒ
```csharp
// æ­£ç¡®çš„å‘½åè§„èŒƒ
public class PlayerController : MonoBehaviour {  // ç±»åï¼šPascalCase
    private float moveSpeed;                    // å˜é‡åï¼šcamelCase
    public const int MAX_HEALTH = 100;          // å¸¸é‡ï¼šSCREAMING_SNAKE_CASE
    public float CurrentHealth { get; set; }     // å±æ€§ï¼šPascalCase

    public void CalculateDamage() { }            // æ–¹æ³•åï¼šPascalCase
    private void UpdatePlayerPosition() { }     // ç§æœ‰æ–¹æ³•ï¼šPascalCase
}

// æ¥å£å‘½å
public interface IDamageable {
    float Health { get; }
    void TakeDamage(float damage);
}

// å§”æ‰˜å’Œäº‹ä»¶
public delegate void HealthChangedHandler(float newHealth);
public event HealthChangedHandler OnHealthChanged;
```

#### 3.1.2 ä»£ç ç»“æ„è§„èŒƒ
```csharp
// ç±»ç»“æ„è§„èŒƒ
public class WellStructuredClass : MonoBehaviour {
    #region Fields and Properties
    [SerializeField] private float moveSpeed = 5f;
    public float MoveSpeed => moveSpeed;

    private Rigidbody2D _rigidbody;
    public Rigidbody2D Rigidbody => _rigidbody;
    #endregion

    #region Unity Lifecycle
    private void Awake() {
        _rigidbody = GetComponent<Rigidbody2D>();
    }

    private void Update() {
        HandleInput();
    }

    private void FixedUpdate() {
        HandleMovement();
    }
    #endregion

    #region Private Methods
    private void HandleInput() {
        // è¾“å…¥å¤„ç†é€»è¾‘
    }

    private void HandleMovement() {
        // ç§»åŠ¨é€»è¾‘
    }
    #endregion

    #region Public Methods
    public void SetSpeed(float newSpeed) {
        moveSpeed = Mathf.Max(0, newSpeed);
    }
    #endregion
}
```

#### 3.1.3 é”™è¯¯å¤„ç†è§„èŒƒ
```csharp
// æ­£ç¡®çš„é”™è¯¯å¤„ç†
public class DataManager {
    public bool SaveGame(SaveData data) {
        try {
            if (data == null) {
                throw new ArgumentNullException(nameof(data));
            }

            if (!ValidateData(data)) {
                return false;
            }

            string jsonData = JsonUtility.ToJson(data, true);
            string filePath = GetSaveFilePath(data.saveId);

            File.WriteAllText(filePath, jsonData);
            return true;
        }
        catch (Exception ex) {
            Debug.LogError($"ä¿å­˜æ¸¸æˆå¤±è´¥: {ex.Message}");
            return false;
        }
    }

    private bool ValidateData(SaveData data) {
        if (string.IsNullOrEmpty(data.saveId)) {
            Debug.LogWarning("å­˜æ¡£IDä¸èƒ½ä¸ºç©º");
            return false;
        }

        return true;
    }
}
```

### 3.2 æ€§èƒ½å®¡æŸ¥æ ‡å‡†

#### 3.2.1 æ€§èƒ½æ•æ„Ÿä»£ç æ£€æŸ¥
```csharp
// æ€§èƒ½æ•æ„Ÿä»£ç ç¤ºä¾‹
public class PerformanceCriticalCode : MonoBehaviour {
    private void Update() {
        // âŒ é”™è¯¯ï¼šåœ¨Updateä¸­è¿›è¡Œé¢‘ç¹çš„å­—ç¬¦ä¸²æ“ä½œ
        string debugText = "Player Position: " + transform.position.x + ", " + transform.position.y;
        Debug.Log(debugText);

        // âœ… æ­£ç¡®ï¼šä½¿ç”¨StringBuilderæˆ–å‡å°‘è°ƒç”¨é¢‘ç‡
        if (Time.frameCount % 60 == 0) { // æ¯ç§’è®°å½•ä¸€æ¬¡
            Debug.Log($"Player Position: {transform.position}");
        }
    }

    // âœ… æ­£ç¡®ï¼šä½¿ç”¨å¯¹è±¡æ± 
    public class BulletPool : MonoBehaviour {
        private Queue<GameObject> bulletPool = new Queue<GameObject>();
        private GameObject bulletPrefab;

        public GameObject GetBullet() {
            if (bulletPool.Count > 0) {
                GameObject bullet = bulletPool.Dequeue();
                bullet.SetActive(true);
                return bullet;
            }

            return Instantiate(bulletPrefab);
        }

        public void ReturnBullet(GameObject bullet) {
            bullet.SetActive(false);
            bulletPool.Enqueue(bullet);
        }
    }
}
```

#### 3.2.2 å†…å­˜ç®¡ç†æ£€æŸ¥
```csharp
// æ­£ç¡®çš„å†…å­˜ç®¡ç†
public class MemoryManager : MonoBehaviour {
    private List<Texture2D> loadedTextures = new List<Texture2D>();

    // âœ… æ­£ç¡®ï¼šåŠæ—¶é‡Šæ”¾èµ„æº
    public void LoadTextures(string[] texturePaths) {
        foreach (string path in texturePaths) {
            StartCoroutine(LoadTextureAsync(path));
        }
    }

    private IEnumerator LoadTextureAsync(string path) {
        ResourceRequest request = Resources.LoadAsync<Texture2D>(path);
        yield return request;

        if (request.asset != null) {
            Texture2D texture = request.asset as Texture2D;
            loadedTextures.Add(texture);
        }
    }

    // âœ… æ­£ç¡®ï¼šåœºæ™¯å¸è½½æ—¶æ¸…ç†èµ„æº
    private void OnDestroy() {
        foreach (var texture in loadedTextures) {
            if (texture != null) {
                Resources.UnloadAsset(texture);
            }
        }
        loadedTextures.Clear();
    }
}
```

### 3.3 å®‰å…¨æ€§å®¡æŸ¥æ ‡å‡†

#### 3.3.1 æ•°æ®å®‰å…¨æ£€æŸ¥
```csharp
// å®‰å…¨çš„æ•°æ®å¤„ç†
public class SecureDataManager {
    private string encryptionKey = "SecureKey123!";

    // âœ… æ­£ç¡®ï¼šæ•°æ®åŠ å¯†
    public string EncryptData(string data) {
        if (string.IsNullOrEmpty(data)) {
            throw new ArgumentException("æ•°æ®ä¸èƒ½ä¸ºç©º");
        }

        try {
            byte[] dataBytes = Encoding.UTF8.GetBytes(data);
            using (Aes aes = Aes.Create()) {
                aes.Key = Encoding.UTF8.GetBytes(encryptionKey.PadRight(32).Substring(0, 32));
                aes.IV = new byte[16];

                using (MemoryStream ms = new MemoryStream()) {
                    using (CryptoStream cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write)) {
                        cs.Write(dataBytes, 0, dataBytes.Length);
                    }
                    return Convert.ToBase64String(ms.ToArray());
                }
            }
        }
        catch (Exception ex) {
            Debug.LogError($"æ•°æ®åŠ å¯†å¤±è´¥: {ex.Message}");
            throw;
        }
    }

    // âœ… æ­£ç¡®ï¼šè¾“å…¥éªŒè¯
    public bool ValidateInput(string input, int maxLength = 100) {
        if (string.IsNullOrEmpty(input)) {
            return false;
        }

        if (input.Length > maxLength) {
            return false;
        }

        // æ£€æŸ¥SQLæ³¨å…¥ç­‰å®‰å…¨é£é™©
        if (input.Contains("DROP") || input.Contains("DELETE") || input.Contains("'")) {
            return false;
        }

        return true;
    }
}
```

---

## å››ã€å®¡æŸ¥å·¥å…·å’Œæ£€æŸ¥æ¸…å•

### 4.1 é™æ€ä»£ç åˆ†æå·¥å…·

#### 4.1.1 ReSharperé…ç½®
```xml
<!-- ReSharperé…ç½®ç¤ºä¾‹ -->
<CodeInspectionProfile>
    < inspections>
        <inspection tool="ReSharper" severity="WARNING">
            <option name="CheckForNamespaceConsistency" value="true" />
            <option name="CheckForMethodOverloads" value="true" />
            <option name="CheckForParameterOrder" value="true" />
        </inspection>

        <inspection tool="Unity" severity="ERROR">
            <option name="CheckForPerformanceIssues" value="true" />
            <option name="CheckForMemoryLeaks" value="true" />
            <option name="CheckForNullReferences" value="true" />
        </inspection>
    </inspections>
</CodeInspectionProfile>
```

#### 4.1.2 è‡ªå®šä¹‰è§„åˆ™æ£€æŸ¥å™¨
```csharp
// è‡ªå®šä¹‰ä»£ç æ£€æŸ¥å™¨
public class CustomCodeAnalyzer {
    // æ£€æŸ¥æ–¹æ³•é•¿åº¦
    public bool CheckMethodLength(MethodDeclarationSyntax method, int maxLength = 50) {
        int lineCount = method.GetLocation().GetLineSpan().EndLinePosition.Line -
                       method.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
        return lineCount <= maxLength;
    }

    // æ£€æŸ¥åœˆå¤æ‚åº¦
    public int CalculateCyclomaticComplexity(MethodDeclarationSyntax method) {
        int complexity = 1; // åŸºç¡€å¤æ‚åº¦

        // æ£€æŸ¥æ§åˆ¶ç»“æ„
        complexity += method.DescendantNodes()
            .Count(node => node is IfStatementSyntax ||
                            node is ForStatementSyntax ||
                            node is WhileStatementSyntax ||
                            node is DoStatementSyntax ||
                            node is SwitchStatementSyntax);

        return complexity;
    }

    // æ£€æŸ¥å¼‚å¸¸å¤„ç†
    public bool HasProperExceptionHandling(MethodDeclarationSyntax method) {
        return method.DescendantNodes()
            .Any(node => node is TryStatementSyntax);
    }
}
```

### 4.2 ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•

#### 4.2.1 é€šç”¨æ£€æŸ¥æ¸…å•
```markdown
## é€šç”¨ä»£ç å®¡æŸ¥æ¸…å•

### ä»£ç è´¨é‡
- [ ] ä»£ç ç¬¦åˆé¡¹ç›®ç¼–ç è§„èŒƒ
- [ ] ç±»å’Œæ–¹æ³•å‘½åæ¸…æ™°æ˜ç¡®
- [ ] ä»£ç ç»“æ„åˆç†ï¼ŒèŒè´£å•ä¸€
- [ ] ä»£ç å¯è¯»æ€§è‰¯å¥½
- [ ] æ³¨é‡Šæ¸…æ™°ä¸”å¿…è¦

### åŠŸèƒ½å®ç°
- [ ] å®ç°ç¬¦åˆéœ€æ±‚å’Œè®¾è®¡
- [ ] é€»è¾‘æ­£ç¡®ä¸”å®Œæ•´
- [ ] è¾¹ç•Œæƒ…å†µå¤„ç†å®Œå–„
- [ ] å¼‚å¸¸å¤„ç†å®Œæ•´
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%

### æ€§èƒ½è€ƒè™‘
- [ ] é¿å…ä¸å¿…è¦çš„è®¡ç®—å’Œå†…å­˜åˆ†é…
- [ ] ä½¿ç”¨å¯¹è±¡æ± ç®¡ç†é¢‘ç¹åˆ›å»ºé”€æ¯çš„å¯¹è±¡
- [ ] å¼‚æ­¥æ“ä½œæ­£ç¡®ä½¿ç”¨
- [ ] èµ„æºåŠ è½½å’Œé‡Šæ”¾åˆç†
- [ ] ç®—æ³•å¤æ‚åº¦åˆç†

### å®‰å…¨æ€§
- [ ] è¾“å…¥éªŒè¯å®Œæ•´
- [ ] æ•°æ®åŠ å¯†ä¿æŠ¤
- [ ] æƒé™æ£€æŸ¥æ­£ç¡®
- [ ] é˜²æ­¢æ³¨å…¥æ”»å‡»
- [ ] æ•æ„Ÿä¿¡æ¯ä¿æŠ¤

### Unityç‰¹å®š
- [ ] Unityç”Ÿå‘½å‘¨æœŸæ­£ç¡®ä½¿ç”¨
- [ ] MonoBehaviouræ¨¡å¼æ­£ç¡®
- [ ] åºåˆ—åŒ–å­—æ®µæ­£ç¡®
- [ ] èµ„æºå¼•ç”¨æ­£ç¡®
- [ ] åœºæ™¯åˆ‡æ¢å¤„ç†åˆç†
```

#### 4.2.2 ç³»ç»Ÿç‰¹å®šæ£€æŸ¥æ¸…å•
```markdown
## æˆ˜æ–—ç³»ç»Ÿå®¡æŸ¥æ¸…å•
- [ ] ä¼¤å®³è®¡ç®—å…¬å¼æ­£ç¡®
- [ ] çŠ¶æ€æ•ˆæœåº”ç”¨åˆç†
- [ ] åŠ¨ç”»çŠ¶æ€æœºé…ç½®æ­£ç¡®
- [ ] ç¢°æ’æ£€æµ‹å‡†ç¡®
- [ ] æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡

## è§’è‰²ç³»ç»Ÿå®¡æŸ¥æ¸…å•
- [ ] å±æ€§è®¡ç®—å‡†ç¡®
- [ ] ç­‰çº§ç³»ç»Ÿæ­£ç¡®
- [ ] æŠ€èƒ½ç³»ç»Ÿå®Œæ•´
- [ ] è£…å¤‡ç³»ç»Ÿæ­£ç¡®
- [ ] çŠ¶æ€ç®¡ç†åˆç†

## UIç³»ç»Ÿå®¡æŸ¥æ¸…å•
- [ ] UIå¸ƒå±€æ­£ç¡®
- [ ] äº‹ä»¶å¤„ç†åˆç†
- [ ] åŠ¨ç”»æ•ˆæœæµç•…
- [ ] æœ¬åœ°åŒ–æ”¯æŒ
- [ ] æ€§èƒ½ä¼˜åŒ–åˆ°ä½
```

---

## äº”ã€å®¡æŸ¥åé¦ˆå’Œè·Ÿè¸ª

### 5.1 åé¦ˆæ¨¡æ¿

#### 5.1.1 å»ºè®¾æ€§åé¦ˆæ¨¡æ¿
```markdown
## ä»£ç å®¡æŸ¥åé¦ˆ

### æ€»ä½“è¯„ä»·
**è¯„åˆ†**: â­â­â­â­â˜† (4/5)
**æ€»ä½“è¯„ä»·**: ä»£ç è´¨é‡è‰¯å¥½ï¼Œä¸»è¦åŠŸèƒ½å®ç°æ­£ç¡®ï¼Œä½†æœ‰å‡ ä¸ªå°çš„æ”¹è¿›ç‚¹ã€‚

### å…·ä½“åé¦ˆ

#### ğŸ‘ ä¼˜ç‚¹
1. ä»£ç ç»“æ„æ¸…æ™°ï¼Œæ–¹æ³•èŒè´£å•ä¸€
2. å¼‚å¸¸å¤„ç†å®Œæ•´
3. å•å…ƒæµ‹è¯•è¦†ç›–ç‡é«˜
4. æ€§èƒ½è€ƒè™‘å……åˆ†

#### ğŸ”§ æ”¹è¿›å»ºè®®
1. **æ–‡ä»¶**: `PlayerController.cs`
   **è¡Œæ•°**: 45-50
   **é—®é¢˜**: æ–¹æ³•è¿‡é•¿ï¼Œå»ºè®®æ‹†åˆ†
   **å»ºè®®**: å°†`HandleInput`æ–¹æ³•æ‹†åˆ†ä¸ºæ›´å°çš„æ–¹æ³•

2. **æ–‡ä»¶**: `CombatManager.cs`
   **è¡Œæ•°**: 120-125
   **é—®é¢˜**: ç¡¬ç¼–ç çš„é­”æ³•æ•°å­—
   **å»ºè®®**: ä½¿ç”¨å¸¸é‡æˆ–é…ç½®æ–‡ä»¶

3. **æ–‡ä»¶**: `DataManager.cs`
   **è¡Œæ•°**: 200-205
   **é—®é¢˜**: å¼‚å¸¸å¤„ç†è¿‡äºå®½æ³›
   **å»ºè®®**: æ•è·ç‰¹å®šçš„å¼‚å¸¸ç±»å‹

### å®¡æŸ¥ç»“è®º
**çŠ¶æ€**: éœ€è¦ä¿®æ”¹
**é¢„è®¡ä¿®æ”¹æ—¶é—´**: 1-2å°æ—¶
**ä¸‹æ¬¡å®¡æŸ¥**: å»ºè®®ä¿®æ”¹åå†æ¬¡å®¡æŸ¥
```

### 5.2 ç¼ºé™·è·Ÿè¸ª

#### 5.2.1 ä»£ç ç¼ºé™·åˆ†ç±»
```csharp
// ç¼ºé™·ä¸¥é‡çº§åˆ«å®šä¹‰
public enum CodeDefectSeverity {
    Critical,    // å¯¼è‡´ç³»ç»Ÿå´©æºƒæˆ–æ•°æ®ä¸¢å¤±
    Major,       // å½±å“æ ¸å¿ƒåŠŸèƒ½
    Minor,       // å½±å“éæ ¸å¿ƒåŠŸèƒ½
    Cosmetic,    // ä»…å½±å“ä»£ç è´¨é‡
    Suggestion   // æ”¹è¿›å»ºè®®
}

// ç¼ºé™·ç±»å‹å®šä¹‰
public enum CodeDefectType {
    Bug,         // åŠŸèƒ½é”™è¯¯
    Performance, // æ€§èƒ½é—®é¢˜
    Security,    // å®‰å…¨æ¼æ´
    Maintainability, // å¯ç»´æŠ¤æ€§é—®é¢˜
    Standards    // ç¼–ç è§„èŒƒé—®é¢˜
}
```

#### 5.2.2 ç¼ºé™·ä¿®å¤è·Ÿè¸ª
```csharp
// ç¼ºé™·è·Ÿè¸ªç³»ç»Ÿ
public class CodeDefectTracker {
    public class Defect {
        public string Id { get; set; }
        public string Description { get; set; }
        public CodeDefectSeverity Severity { get; set; }
        public CodeDefectType Type { get; set; }
        public string File { get; set; }
        public int LineNumber { get; set; }
        public string Assignee { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? FixedAt { get; set; }
        public DefectStatus Status { get; set; }
    }

    public enum DefectStatus {
        Open,
        InProgress,
        Resolved,
        Closed,
        Rejected
    }

    public void CreateDefect(Defect defect) {
        // åˆ›å»ºç¼ºé™·è®°å½•
    }

    public void UpdateDefectStatus(string defectId, DefectStatus status) {
        // æ›´æ–°ç¼ºé™·çŠ¶æ€
    }

    public List<Defect> GetDefectsByAssignee(string assignee) {
        // è·å–æŒ‡å®šå¼€å‘è€…çš„ç¼ºé™·
        return new List<Defect>();
    }
}
```

---

## å…­ã€ä»£ç è´¨é‡åº¦é‡

### 6.1 è´¨é‡æŒ‡æ ‡

#### 6.1.1 ä»£ç è´¨é‡è¯„åˆ†ç³»ç»Ÿ
```csharp
// ä»£ç è´¨é‡è¯„åˆ†è®¡ç®—å™¨
public class CodeQualityScorer {
    public CodeQualityScore CalculateScore(CodeAnalysisResult analysis) {
        var score = new CodeQualityScore();

        // è®¡ç®—å„é¡¹æŒ‡æ ‡å¾—åˆ†
        score.CodingStandardsScore = CalculateCodingStandardsScore(analysis);
        score.TestCoverageScore = CalculateTestCoverageScore(analysis);
        score.PerformanceScore = CalculatePerformanceScore(analysis);
        score.SecurityScore = CalculateSecurityScore(analysis);
        score.MaintainabilityScore = CalculateMaintainabilityScore(analysis);

        // è®¡ç®—æ€»åˆ†
        score.TotalScore = CalculateTotalScore(score);

        return score;
    }

    private float CalculateCodingStandardsScore(CodeAnalysisResult analysis) {
        float violationsCount = analysis.CodingStandardsViolations.Count;
        float maxViolations = 10; // æœ€å¤§å…è®¸è¿è§„æ•°
        return Math.Max(0, 100 - (violationsCount / maxViolations * 100));
    }

    private float CalculateTestCoverageScore(CodeAnalysisResult analysis) {
        return analysis.TestCoverage;
    }

    private float CalculatePerformanceScore(CodeAnalysisResult analysis) {
        float performanceIssuesCount = analysis.PerformanceIssues.Count;
        float maxIssues = 5; // æœ€å¤§å…è®¸æ€§èƒ½é—®é¢˜æ•°
        return Math.Max(0, 100 - (performanceIssuesCount / maxIssues * 100));
    }

    private float CalculateSecurityScore(CodeAnalysisResult analysis) {
        float securityIssuesCount = analysis.SecurityIssues.Count;
        float maxIssues = 3; // æœ€å¤§å…è®¸å®‰å…¨é—®é¢˜æ•°
        return Math.Max(0, 100 - (securityIssuesCount / maxIssues * 100));
    }

    private float CalculateMaintainabilityScore(CodeAnalysisResult analysis) {
        float complexity = analysis.AverageCyclomaticComplexity;
        float maxComplexity = 15; // æœ€å¤§å…è®¸å¤æ‚åº¦
        return Math.Max(0, 100 - (complexity / maxComplexity * 100));
    }

    private float CalculateTotalScore(CodeQualityScore score) {
        return (score.CodingStandardsScore * 0.25f +
                score.TestCoverageScore * 0.25f +
                score.PerformanceScore * 0.20f +
                score.SecurityScore * 0.15f +
                score.MaintainabilityScore * 0.15f);
    }
}

public class CodeQualityScore {
    public float TotalScore { get; set; }
    public float CodingStandardsScore { get; set; }
    public float TestCoverageScore { get; set; }
    public float PerformanceScore { get; set; }
    public float SecurityScore { get; set; }
    public float MaintainabilityScore { get; set; }
    public QualityGrade Grade => GetGrade(TotalScore);

    private QualityGrade GetGrade(float score) {
        if (score >= 90) return QualityGrade.A;
        if (score >= 80) return QualityGrade.B;
        if (score >= 70) return QualityGrade.C;
        if (score >= 60) return QualityGrade.D;
        return QualityGrade.F;
    }
}

public enum QualityGrade {
    A, B, C, D, F
}
```

### 6.2 è´¨é‡è¶‹åŠ¿åˆ†æ

#### 6.2.1 è´¨é‡è¶‹åŠ¿å›¾è¡¨
```csharp
// è´¨é‡è¶‹åŠ¿åˆ†æå™¨
public class QualityTrendAnalyzer {
    public QualityTrend AnalyzeTrend(List<CodeQualityScore> scores) {
        var trend = new QualityTrend();

        if (scores.Count < 2) {
            trend.Direction = TrendDirection.InsufficientData;
            return trend;
        }

        float totalChange = scores.Last().TotalScore - scores.First().TotalScore;
        float averageChange = totalChange / (scores.Count - 1);

        trend.TotalScoreChange = totalChange;
        trend.AverageChangePerReview = averageChange;
        trend.Direction = GetTrendDirection(averageChange);

        return trend;
    }

    private TrendDirection GetTrendDirection(float averageChange) {
        if (averageChange > 2) return TrendDirection.Improving;
        if (averageChange < -2) return TrendDirection.Degrading;
        return TrendDirection.Stable;
    }
}

public class QualityTrend {
    public TrendDirection Direction { get; set; }
    public float TotalScoreChange { get; set; }
    public float AverageChangePerReview { get; set; }
}

public enum TrendDirection {
    Improving,
    Stable,
    Degrading,
    InsufficientData
}
```

---

## ä¸ƒã€æœ€ä½³å®è·µå’ŒæŒ‡å¯¼

### 7.1 å®¡æŸ¥æœ€ä½³å®è·µ

#### 7.1.1 æœ‰æ•ˆå®¡æŸ¥æŠ€å·§
```markdown
## æœ‰æ•ˆä»£ç å®¡æŸ¥æŠ€å·§

### å®¡æŸ¥å‰å‡†å¤‡
1. äº†è§£å˜æ›´èƒŒæ™¯å’Œéœ€æ±‚
2. ç†Ÿæ‚‰ç›¸å…³çš„ä»£ç æ¨¡å—
3. å‡†å¤‡å¥½å®¡æŸ¥æ¸…å•
4. å®‰æ’å……è¶³çš„å®¡æŸ¥æ—¶é—´

### å®¡æŸ¥è¿‡ç¨‹ä¸­
1. å…ˆç†è§£æ•´ä½“è®¾è®¡ï¼Œå†å…³æ³¨ç»†èŠ‚
2. æä¾›å»ºè®¾æ€§çš„åé¦ˆ
3. è§£é‡Šé—®é¢˜å’Œå»ºè®®çš„åŸå› 
4. ä½¿ç”¨å…·ä½“çš„ä¾‹å­è¯´æ˜é—®é¢˜
5. å…³æ³¨é‡è¦çš„é—®é¢˜ï¼Œé¿å…è¿‡åº¦å…³æ³¨ç»†èŠ‚

### åé¦ˆæŠ€å·§
1. ä½¿ç”¨"ä¸‰æ˜æ²»"åé¦ˆæ³•
2. é¿å…ä¸ªäººæ”»å‡»ï¼Œå…³æ³¨ä»£ç æœ¬èº«
3. æä¾›æ”¹è¿›å»ºè®®ï¼Œä¸ä»…ä»…æ˜¯æŒ‡å‡ºé—®é¢˜
4. è‚¯å®šå¥½çš„å®è·µå’Œæ”¹è¿›
5. ä¿æŒå¼€æ”¾çš„å¿ƒæ€ï¼Œæ¥å—è®¨è®º

### å¸¸è§é—®é¢˜é¿å…
1. é¿å…è¿‡äºå…³æ³¨ä»£ç é£æ ¼
2. é¿å…å¯¹ä¸ªäººç¼–ç¨‹ä¹ æƒ¯çš„åè§
3. é¿å…åœ¨æ²¡æœ‰ç†è§£çš„æƒ…å†µä¸‹æå‡ºé—®é¢˜
4. é¿å…å»¶è¿Ÿå®¡æŸ¥ï¼Œå½±å“å¼€å‘è¿›åº¦
5. é¿å…è¿‡äºä¸¥æ ¼çš„å®¡æŸ¥æ ‡å‡†
```

### 7.2 å®¡æŸ¥æ•ˆç‡ä¼˜åŒ–

#### 7.2.1 åˆ†å±‚æ¬¡å®¡æŸ¥ç­–ç•¥
```csharp
// åˆ†å±‚æ¬¡å®¡æŸ¥ç³»ç»Ÿ
public class TieredCodeReviewSystem {
    public enum ReviewTier {
        Quick,      // å¿«é€Ÿå®¡æŸ¥ï¼šå°æ”¹åŠ¨ã€æ–‡æ¡£æ›´æ–°
        Standard,   // æ ‡å‡†å®¡æŸ¥ï¼šæ–°åŠŸèƒ½ã€Bugä¿®å¤
        Comprehensive // å…¨é¢å®¡æŸ¥ï¼šæ ¸å¿ƒç³»ç»Ÿã€é‡å¤§å˜æ›´
    }

    public ReviewTier DetermineReviewTier(CodeChange change) {
        // æ ¹æ®å˜æ›´å¤æ‚åº¦ç¡®å®šå®¡æŸ¥å±‚çº§
        if (change.FilesChanged <= 2 && change.LinesAdded <= 50) {
            return ReviewTier.Quick;
        }

        if (change.FilesChanged <= 5 && change.LinesAdded <= 200) {
            return ReviewTier.Standard;
        }

        return ReviewTier.Comprehensive;
    }

    public TimeSpan GetReviewTimeLimit(ReviewTier tier) {
        return tier switch {
            ReviewTier.Quick => TimeSpan.FromHours(1),
            ReviewTier.Standard => TimeSpan.FromHours(4),
            ReviewTier.Comprehensive => TimeSpan.FromHours(8),
            _ => TimeSpan.FromHours(4)
        };
    }

    public int GetRequiredReviewers(ReviewTier tier) {
        return tier switch {
            ReviewTier.Quick => 1,
            ReviewTier.Standard => 2,
            ReviewTier.Comprehensive => 3,
            _ => 2
        };
    }
}
```

---

## å…«ã€æ€»ç»“

è¿™ä¸ªä»£ç å®¡æŸ¥æµç¨‹æ–‡æ¡£æä¾›äº†å®Œæ•´çš„è´¨é‡ä¿è¯ä½“ç³»ï¼ŒåŒ…å«äº†ï¼š

1. **æ ‡å‡†åŒ–æµç¨‹**: ä»å¼€å‘åˆ°å®¡æŸ¥çš„å®Œæ•´æµç¨‹
2. **è¯¦ç»†æ ‡å‡†**: ç¼–ç è§„èŒƒã€æ€§èƒ½æ ‡å‡†ã€å®‰å…¨æ ‡å‡†
3. **æ£€æŸ¥æ¸…å•**: å…¨é¢çš„å®¡æŸ¥æ£€æŸ¥æ¸…å•
4. **å·¥å…·æ”¯æŒ**: é™æ€åˆ†æå·¥å…·å’Œè‡ªå®šä¹‰æ£€æŸ¥å™¨
5. **è´¨é‡åº¦é‡**: å®Œæ•´çš„è´¨é‡è¯„åˆ†å’Œè¶‹åŠ¿åˆ†æ
6. **æœ€ä½³å®è·µ**: æœ‰æ•ˆå®¡æŸ¥çš„æŠ€å·§å’Œæ–¹æ³•

è¿™ä¸ªä»£ç å®¡æŸ¥æµç¨‹ç¡®ä¿ä»£ç è´¨é‡è¾¾åˆ°é«˜æ ‡å‡†ï¼Œä¸ºé¡¹ç›®çš„é•¿æœŸç»´æŠ¤å’Œæ‰©å±•å¥ å®šåšå®åŸºç¡€ã€‚